# SKILL: cadquery-codegen — CadQuery Code Generation

## Identity
Parametric CadQuery code generator for FDM 3D printing.
Produces standalone Python scripts that export .STEP + .STL.

---

## 1. Mandatory Python Template

Every generated script MUST follow this structure:

```python
"""[COMPONENT NAME] — Generated by Claude CLI
Date: YYYY-MM-DD
Description: [brief description of the part]
"""
import cadquery as cq

# === MAIN PARAMETERS ===
width  = 40.0   # [mm] external width
depth  = 30.0   # [mm] external depth
height = 20.0   # [mm] external height

# === PRINT PARAMETERS ===
wall       = 2.0   # [mm] wall thickness
fillet_r   = 1.5   # [mm] corner fillet radius
clearance  = 0.3   # [mm] fit clearance

# === DERIVED PARAMETERS ===
inner_w = width  - 2 * wall   # [mm] internal width
inner_d = depth  - 2 * wall   # [mm] internal depth
inner_h = height - wall        # [mm] internal height

# === CONSTRUCTION ===
def make_body():
    """Main body of the part."""
    return (
        cq.Workplane("XY")
        .box(width, depth, height)
        .edges("|Z")
        .fillet(fillet_r)
    )

def make_features(body):
    """Adds features to the body (holes, pockets, etc.)."""
    return (
        body
        .faces(">Z")
        .workplane()
        .hole(5.0)
    )

def make_assembly():
    """Assembles all parts."""
    body = make_body()
    body = make_features(body)
    return body

# === EXPORT ===
result = make_assembly()

cq.exporters.export(result, "output.step")
cq.exporters.export(result, "output.stl")

bb = result.val().BoundingBox()
print(f"BB: {bb.xmin:.2f},{bb.ymin:.2f},{bb.zmin:.2f} -> {bb.xmax:.2f},{bb.ymax:.2f},{bb.zmax:.2f}")
print(f"SIZE: {bb.xlen:.2f} x {bb.ylen:.2f} x {bb.zlen:.2f} mm")
```

---

## 2. Code Rules

### Naming and Style
- **snake_case** for all variables and functions
- Every parameter with comment `# [mm]` or `# [deg]`
- Separate functions for each logical component (`make_body`, `make_lid`, `make_hinge`)
- NEVER magic numbers — every numeric value is a parametric variable

### Fluent API
- Use method chaining where it improves readability
- Line break for each operation in the chain (one per line)
- Outer parentheses for multi-line chains

```python
# GOOD
result = (
    cq.Workplane("XY")
    .box(width, depth, height)
    .edges("|Z")
    .fillet(fillet_r)
    .faces(">Z")
    .workplane()
    .hole(bore_d)
)

# BAD
result = cq.Workplane("XY").box(width, depth, height).edges("|Z").fillet(fillet_r).faces(">Z").workplane().hole(bore_d)
```

### Operation Order
1. Primitives (box, cylinder, sphere)
2. Boolean operations (cut, union, intersect)
3. **Fillet/chamfer AFTER booleans** — never before
4. Secondary features (holes, pockets)
5. Export

### Selectors
- Use explicit face selectors: `">Z"`, `"<Z"`, `">X"`, `"<Y"`, `"|Z"`, `"#Z"`
- Document the selected face with a comment if not obvious
- Prefer relative selectors over index-based selectors

### Export
- ALWAYS export both `.step` and `.stl`
- ALWAYS print the bounding box at the end of the script
- For multi-part assemblies, export each part separately + full assembly

---

## 3. CadQuery Cheat Sheet

### 3.1 Creating Primitives

```python
# Box centered on origin
cq.Workplane("XY").box(length, width, height)

# Non-centered box (centered=(False, False, False))
cq.Workplane("XY").box(length, width, height, centered=(False, False, False))

# Cylinder
cq.Workplane("XY").cylinder(height, radius)

# Sphere
cq.Workplane("XY").sphere(radius)

# Wedge
cq.Workplane("XZ").polyline([(0,0), (base,0), (0,height)]).close().extrude(depth)
```

### 3.2 Face and Edge Selectors

```python
# Faces by direction
.faces(">Z")    # top face (Z max)
.faces("<Z")    # bottom face (Z min)
.faces(">X")    # right face (X max)
.faces("<X")    # left face (X min)
.faces(">Y")    # rear face (Y max)
.faces("<Y")    # front face (Y min)

# Edges by orientation
.edges("|Z")    # edges parallel to Z (vertical)
.edges("|X")    # edges parallel to X
.edges("|Y")    # edges parallel to Y
.edges("#Z")    # edges perpendicular to Z (horizontal)

# Combinations with filters
.edges(">Z")           # edges on top border
.edges("<Z")           # edges on bottom border
.faces(">Z").edges()   # all edges of the top face

# Index-based selector (avoid if possible)
.faces().item(0)

# Near-point selector
.edges(cq.selectors.NearestToPointSelector((x, y, z)))
```

### 3.3 2D to 3D Operations

```python
# Sketch -> Extrude
.rect(w, h).extrude(depth)
.circle(r).extrude(depth)
.polygon(n_sides, diameter).extrude(depth)

# Polyline -> Extrude
.polyline([(x1,y1), (x2,y2), ...]).close().extrude(depth)

# Revolve (around an axis)
.polyline([(x1,y1), (x2,y2), ...]).close().revolve(angle_deg, (0,0,0), (0,1,0))

# Loft between sections
.rect(w1, h1)
.workplane(offset=dist)
.rect(w2, h2)
.loft()

# Sweep along a path
path = cq.Workplane("XZ").spline([(0,0), (10,10), (20,0)])
cq.Workplane("XY").circle(r).sweep(path)
```

### 3.4 Holes

```python
# Through hole
.hole(diameter)

# Blind hole (specified depth)
.hole(diameter, depth)

# Counterbore hole
.cboreHole(diameter, cboreDiameter, cboreDepth)

# Countersink hole
.cskHole(diameter, cskDiameter, cskAngle)
```

### 3.5 Patterns

```python
# Rectangular array
.rarray(x_spacing, y_spacing, x_count, y_count)

# Polar pattern
.polarArray(radius, start_angle, angle, count)

# Explicit points
.pushPoints([(x1,y1), (x2,y2), ...])
```

### 3.6 Fillet and Chamfer

```python
# Fillet on specific edges
.edges("|Z").fillet(radius)

# Fillet on all edges
.edges().fillet(radius)

# Chamfer
.edges("|Z").chamfer(length)

# Asymmetric chamfer
.edges("|Z").chamfer(length1, length2)
```

### 3.7 Boolean Operations

```python
# Union
body = part_a.union(part_b)

# Subtraction
body = part_a.cut(part_b)

# Intersection
body = part_a.intersect(part_b)
```

### 3.8 Workplane and Transformations

```python
# Workplane on a face
.faces(">Z").workplane()

# Offset workplane
.workplane(offset=10)

# Workplane with shifted center
.faces(">Z").workplane().center(dx, dy)

# Transformations
.translate((dx, dy, dz))
.rotate((0,0,0), (0,0,1), angle_deg)
.mirror("XY")
```

### 3.9 Shell (hollowing)

```python
# Shell removing the top face
.faces(">Z").shell(-wall_thickness)

# Shell outward
.faces(">Z").shell(wall_thickness)
```

### 3.10 Assembly

```python
assy = cq.Assembly()
assy.add(part_a, name="base", color=cq.Color("gray"))
assy.add(part_b, name="lid", loc=cq.Location((0, 0, height)))
assy.save("assembly.step")
```

### 3.11 Export

```python
# STEP (exact BREP)
cq.exporters.export(shape, "output.step")

# STL (triangulated mesh)
cq.exporters.export(shape, "output.stl")

# STL with custom tolerance
cq.exporters.export(shape, "output.stl", tolerance=0.01, angularTolerance=0.1)

# SVG (2D projection)
cq.exporters.export(shape, "output.svg", exportType="SVG")

# DXF (2D profile)
cq.exporters.exportDXF(shape, "output.dxf")

# 3MF
cq.exporters.export(shape, "output.3mf")
```

### 3.12 Measurements and Debug

```python
# Bounding box
bb = result.val().BoundingBox()
print(f"Size: {bb.xlen:.2f} x {bb.ylen:.2f} x {bb.zlen:.2f} mm")

# Volume
vol = result.val().Volume()
print(f"Volume: {vol:.2f} mm3")

# Surface area
area = sum(f.Area() for f in result.val().Faces())
print(f"Surface area: {area:.2f} mm2")

# Face/edge count
n_faces = len(result.val().Faces())
n_edges = len(result.val().Edges())
```

---

## 4. Anti-Patterns

### 4.1 Magic Numbers
```python
# BAD
result = cq.Workplane("XY").box(40, 30, 20).edges("|Z").fillet(1.5)

# GOOD
width    = 40.0   # [mm]
depth    = 30.0   # [mm]
height   = 20.0   # [mm]
fillet_r =  1.5   # [mm]
result = cq.Workplane("XY").box(width, depth, height).edges("|Z").fillet(fillet_r)
```

### 4.2 Fillet Before Booleans
```python
# BAD — fillet before cut, risk of kernel crash
body = cq.Workplane("XY").box(40, 30, 20).edges("|Z").fillet(2)
body = body.cut(cq.Workplane("XY").box(10, 10, 25))

# GOOD — fillet after all booleans
body = cq.Workplane("XY").box(40, 30, 20)
body = body.cut(cq.Workplane("XY").box(10, 10, 25))
body = body.edges("|Z").fillet(2)
```

### 4.3 Direct Mesh
```python
# BAD — never use numpy-stl or trimesh for creating geometry
import numpy as np
from stl import mesh

# GOOD — always use solid BREP modeling
import cadquery as cq
result = cq.Workplane("XY").box(10, 10, 10)
```

### 4.4 Missing Dual Export
```python
# BAD — STL only
cq.exporters.export(result, "output.stl")

# GOOD — always STEP + STL
cq.exporters.export(result, "output.step")
cq.exporters.export(result, "output.stl")
```

### 4.5 Ambiguous Selectors
```python
# BAD — index-based selector, fragile
.faces().item(2).workplane()

# GOOD — direction-based selector, robust
.faces(">Z").workplane()
```

### 4.6 Unreadable Chains
```python
# BAD — everything on one line
result = cq.Workplane("XY").box(40,30,20).faces(">Z").workplane().rect(20,10).cutBlind(-5).edges("|Z").fillet(2)

# GOOD — one operation per line
result = (
    cq.Workplane("XY")
    .box(40, 30, 20)
    .faces(">Z")
    .workplane()
    .rect(20, 10)
    .cutBlind(-5)
    .edges("|Z")
    .fillet(2)
)
```

### 4.7 No Bounding Box in Output
```python
# BAD — no dimensional verification
cq.exporters.export(result, "output.step")

# GOOD — always print BB for validation
cq.exporters.export(result, "output.step")
bb = result.val().BoundingBox()
print(f"SIZE: {bb.xlen:.2f} x {bb.ylen:.2f} x {bb.zlen:.2f} mm")
```

### 4.8 Undocumented Parameters
```python
# BAD
wall = 2
d = 4.2

# GOOD
wall = 2.0          # [mm] wall thickness
insert_d = 4.2      # [mm] M3 heat insert hole diameter
```

---

## 5. Available Templates

Directory: `skills/cadquery-codegen/templates/`

| Template | Description | Export |
|---|---|---|
| `parametric_box.py` | Box with optional lid and snap-fit | body.step/stl + lid.step/stl |
| `bracket_l.py` | L-bracket with ribs and holes | bracket.step/stl |
| `enclosure.py` | PCB enclosure with standoffs | enclosure.step/stl + lid.step/stl |
| `snap_fit.py` | Cantilever snap-fit module | snap_fit.step/stl |
| `threaded_insert.py` | M2-M5 heat insert holes | insert_boss.step/stl |
| `hinge.py` | 2-part hinge (pin + knuckle) | assembly.step + single part .step/stl |

Every template is a standalone Python script runnable with `python3 template.py`.
